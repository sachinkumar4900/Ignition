{
  "resource-type": "text-resource",
  "content-type": "text/html",
  "text": "\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <title>Voice to Text Demo</title>\r\n</head>\r\n<body>\r\n  <button id=\"startBtn\">Start Listening</button>\r\n  <!-- <button onclick=\"parseQuery(query)\">Parse Query</button> -->\r\n  <script>\r\n    let voiceText = \"\"; // Variable to store final text\r\n    const startBtn = document.getElementById(\"startBtn\");\r\n  \r\n    // Check browser support\r\n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\r\n    if (!SpeechRecognition) {\r\n      alert(\"Your browser does not support Speech Recognition.\");\r\n    } else {\r\n      const recognition = new SpeechRecognition();\r\n      recognition.lang = \"en-IN\";       // Language (Indian English)\r\n      recognition.interimResults = false; // Only final result\r\n      recognition.maxAlternatives = 1;    // Best match\r\n      recognition.continuous = false;     // Stop after user stops speaking\r\n\r\n      startBtn.addEventListener(\"click\", () => {\r\n        startBtn.textContent = \"Listening...\";\r\n        voiceText = \"\"; // Reset before starting\r\n        recognition.start();\r\n      });\r\n\r\n      recognition.onresult = (event) => {\r\n        voiceText = event.results[0][0].transcript; // Store final text\r\n        console.log(\"Voice Text:\", voiceText);// Log to console\r\n        query = voiceText; \r\n          startBtn.textContent = \"Start Listening\";\r\n          parseQuery(query);\r\n          sendData();\r\n      };\r\n\r\n      recognition.onerror = (event) => {\r\n        console.error(\"Error:\", event.error);\r\n      };\r\n\r\n      recognition.onend = () => {\r\n        console.log(\"Stopped listening.\");\r\n      };\r\n    }\r\n    \r\n   </script>\r\n\r\n\r\n   <script>\r\n     // ---------- Formatting ----------\r\n     function formatDt(dt) {\r\n       const pad = (n) => (n < 10 ? \"0\" + n : n);\r\n       return (\r\n         dt.getFullYear() + \"-\" +\r\n         pad(dt.getMonth() + 1) + \"-\" +\r\n         pad(dt.getDate()) + \" \" +\r\n         pad(dt.getHours()) + \":\" +\r\n         pad(dt.getMinutes()) + \":\" +\r\n         pad(dt.getSeconds())\r\n       );\r\n     }\r\n   \r\n     // ---------- Metric detection with persistence ----------\r\n     let persistedMetric = \"ENERGY_CONSUMED\";\r\n   \r\n     function detectMetric(queryLower) {\r\n       const idxEnergy = queryLower.indexOf(\"energy\");\r\n       const idxWater = queryLower.indexOf(\"water\");\r\n   \r\n       if (idxEnergy === -1 && idxWater === -1) {\r\n         return persistedMetric; // keep last chosen (default energy initially)\r\n       }\r\n       if (idxEnergy !== -1 && idxWater !== -1) {\r\n         persistedMetric = idxEnergy < idxWater ? \"ENERGY_CONSUMED\" : \"WATER_CONSUMED\";\r\n         return persistedMetric;\r\n       }\r\n       if (idxWater !== -1) {\r\n         persistedMetric = \"WATER_CONSUMED\";\r\n         return persistedMetric;\r\n       }\r\n       persistedMetric = \"ENERGY_CONSUMED\";\r\n       return persistedMetric;\r\n     }\r\n   \r\n     // ---------- Explicit date parsing helpers ----------\r\n     const MONTH_MAP = {\r\n       jan: 0, january: 0,\r\n       feb: 1, february: 1,\r\n       mar: 2, march: 2,\r\n       apr: 3, april: 3,\r\n       may: 4,\r\n       jun: 5, june: 5,\r\n       jul: 6, july: 6,\r\n       aug: 7, august: 7,\r\n       sep: 8, sept: 8, september: 8,\r\n       oct: 9, october: 9,\r\n       nov: 10, november: 10,\r\n       dec: 11, december: 11\r\n     };\r\n   \r\n     function monthToIndex(m) {\r\n       if (!m) return null;\r\n       const key = m.trim().toLowerCase();\r\n       return Object.prototype.hasOwnProperty.call(MONTH_MAP, key) ? MONTH_MAP[key] : null;\r\n     }\r\n   \r\n     function parseDMY(dayStr, monthStr, yearStr, now) {\r\n       const day = parseInt(dayStr, 10);\r\n       const mi = monthToIndex(monthStr);\r\n       const year = yearStr ? parseInt(yearStr, 10) : now.getFullYear();\r\n       if (isNaN(day) || mi === null || isNaN(year)) return null;\r\n       const d = new Date(year, mi, day);\r\n       return isNaN(d.getTime()) ? null : d;\r\n     }\r\n   \r\n     function parseMDY(monthStr, dayStr, yearStr, now) {\r\n       const day = parseInt(dayStr, 10);\r\n       const mi = monthToIndex(monthStr);\r\n       const year = yearStr ? parseInt(yearStr, 10) : now.getFullYear();\r\n       if (isNaN(day) || mi === null || isNaN(year)) return null;\r\n       const d = new Date(year, mi, day);\r\n       return isNaN(d.getTime()) ? null : d;\r\n     }\r\n   \r\n     function collectExplicitDates(ql, now) {\r\n       const results = [];\r\n       const dmyRe = /(\\d{1,2})(?:st|nd|rd|th)?\\s+(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:t(?:ember)?)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)(?:\\s*,?\\s*(\\d{4}))?/g;\r\n       let m;\r\n       while ((m = dmyRe.exec(ql)) !== null) {\r\n         const d = parseDMY(m[1], m[2], m[3], now);\r\n         if (d) results.push(d);\r\n       }\r\n   \r\n       const mdyRe = /(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:t(?:ember)?)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)\\s+(\\d{1,2})(?:st|nd|rd|th)?(?:\\s*,?\\s*(\\d{4}))?/g;\r\n       while ((m = mdyRe.exec(ql)) !== null) {\r\n         const d = parseMDY(m[1], m[2], m[3], now);\r\n         if (d) results.push(d);\r\n       }\r\n   \r\n       return results;\r\n     }\r\n   \r\n     // ---------- DATE INTENT DETECTION ----------\r\n     function hasDateIntent(ql) {\r\n       // Explicit dates (DMY/MDY)\r\n       if ((/(\\d{1,2})(?:st|nd|rd|th)?\\s+(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:t(?:ember)?)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)(?:\\s*,?\\s*(\\d{4}))?/).test(ql)) {\r\n         return true;\r\n       }\r\n       if ((/(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:t(?:ember)?)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)\\s+(\\d{1,2})(?:st|nd|rd|th)?(?:\\s*,?\\s*(\\d{4}))?/).test(ql)) {\r\n         return true;\r\n       }\r\n   \r\n       // Specific phrases\r\n       if (/\\b(last|previous)\\s+day\\b/.test(ql)) return true;\r\n       if (/\\b(last|previous)\\s+month\\b/.test(ql)) return true;\r\n   \r\n       // Relative windows\r\n       if (/\\b(\\d+)\\s+days?\\b/.test(ql)) return true;\r\n       if (/\\b(\\d+)\\s+months?\\b/.test(ql)) return true;\r\n   \r\n       // Keywords\r\n       if (ql.includes(\"today\") || ql.includes(\"current\") || ql.includes(\"yesterday\") || ql.includes(\"previous\")) return true;\r\n   \r\n       return false;\r\n     }\r\n   \r\n     // Helper: full previous calendar month range\r\n     function getLastMonthRange(now) {\r\n       const year = now.getFullYear();\r\n       const month = now.getMonth(); // 0-11\r\n       const prevMonth = month === 0 ? 11 : month - 1;\r\n       const prevYear = month === 0 ? year - 1 : year;\r\n   \r\n       const start = new Date(prevYear, prevMonth, 1);\r\n       start.setHours(0, 0, 0, 0);\r\n   \r\n       const startOfCurrentMonth = new Date(year, month, 1);\r\n       const end = new Date(startOfCurrentMonth.getTime() - 1);\r\n       end.setHours(23, 59, 59, 999);\r\n   \r\n       return [start, end];\r\n     }\r\n   \r\n     // ---------- Main date-range parser ----------\r\n     function parseDateRange(queryLower, now) {\r\n       // 1) Explicit dates\r\n       const explicitDates = collectExplicitDates(queryLower, now);\r\n       if (explicitDates.length >= 2) {\r\n         let start = new Date(explicitDates[0]);\r\n         let end = new Date(explicitDates[1]);\r\n         start.setHours(0, 0, 0, 0);\r\n         end.setHours(23, 59, 59, 999);\r\n         if (end.getTime() < start.getTime()) {\r\n           const tmp = start;\r\n           start = end;\r\n           end = tmp;\r\n         }\r\n         return [start, end];\r\n       } else if (explicitDates.length === 1) {\r\n         const d = explicitDates[0];\r\n         const start = new Date(d);\r\n         start.setHours(0, 0, 0, 0);\r\n         const end = new Date(d);\r\n         end.setHours(23, 59, 59, 999);\r\n         return [start, end];\r\n       }\r\n   \r\n       // 2) Specific phrases: last/previous day & month\r\n       if (/\\b(last|previous)\\s+day\\b/.test(queryLower)) {\r\n         const yest = new Date(now.getTime() - 24 * 60 * 60 * 1000);\r\n         const start = new Date(yest);\r\n         start.setHours(0, 0, 0, 0);\r\n         const end = new Date(yest);\r\n         end.setHours(23, 59, 59, 999);\r\n         return [start, end];\r\n       }\r\n       if (/\\b(last|previous)\\s+month\\b/.test(queryLower)) {\r\n         return getLastMonthRange(now);\r\n       }\r\n   \r\n       // 3) Relative windows\r\n       const matchDays = queryLower.match(/\\b(\\d+)\\s+days?\\b/);\r\n       if (matchDays) {\r\n         const n = parseInt(matchDays[1], 10);\r\n         const start = new Date(now.getTime() - n * 24 * 60 * 60 * 1000);\r\n         return [start, now];\r\n       }\r\n       const matchMonths = queryLower.match(/\\b(\\d+)\\s+months?\\b/);\r\n       if (matchMonths) {\r\n         const n = parseInt(matchMonths[1], 10);\r\n         const start = new Date(now);\r\n         start.setMonth(start.getMonth() - n); // calendar-accurate subtraction\r\n         return [start, now];\r\n       }\r\n   \r\n       // 4) Keywords: today/current, yesterday/previous (generic)\r\n       if (queryLower.includes(\"today\") || queryLower.includes(\"current\")) {\r\n         const start = new Date(now);\r\n         start.setHours(0, 0, 0, 0);\r\n         const end = new Date(now);\r\n         end.setHours(23, 59, 59, 999);\r\n         return [start, end];\r\n       }\r\n       if (queryLower.includes(\"yesterday\") || queryLower.includes(\"previous\")) {\r\n         const yest = new Date(now.getTime() - 24 * 60 * 60 * 1000);\r\n         const start = new Date(yest);\r\n         start.setHours(0, 0, 0, 0);\r\n         const end = new Date(yest);\r\n         end.setHours(23, 59, 59, 999);\r\n         return [start, end];\r\n       }\r\n   \r\n       // 5) Fallback: today\r\n       const start = new Date(now);\r\n       start.setHours(0, 0, 0, 0);\r\n       const end = new Date(now);\r\n       end.setHours(23, 59, 59, 999);\r\n       return [start, end];\r\n     }\r\n   \r\n     // ---------- High-level parser ----------\r\n     let jsonResult = null;\r\n     function parseQuery(query) {\r\n       const now = new Date();\r\n       const ql = (query || \"\").toLowerCase();\r\n   \r\n       // NEW: detect monthly flag\r\n       const monthlyFlag = /\\bmonthly\\b/.test(ql) ? 'true' : 'false';\r\n   \r\n       // If no date/time intent, return error instead of metrics\r\n       if (!hasDateIntent(ql)) {\r\n         jsonResult = {\r\n           error: \"No date/time mentioned in query\",\r\n           start: null,\r\n           end: null,\r\n           monthly: monthlyFlag\r\n         };\r\n         console.log(\"jsonResult\", JSON.stringify(jsonResult));\r\n         return jsonResult;\r\n       }\r\n   \r\n       // If date intent exists, proceed as normal\r\n       const metric = detectMetric(ql);\r\n       const [startDt, endDt] = parseDateRange(ql, now);\r\n   \r\n       jsonResult = {\r\n         metric,\r\n         start: formatDt(startDt),\r\n         end: formatDt(endDt),\r\n         monthly: monthlyFlag\r\n       };\r\n   srtResult = JSON.stringify(jsonResult);\r\n       console.log(\"jsonResult\", JSON.stringify(jsonResult));\r\n       return jsonResult;\r\n     }\r\n   \r\n     // Expose parseQuery if needed\r\n     window.parseQuery = parseQuery;\r\n   </script>\r\n\r\n\r\n<script>\r\n   async function sendData() {\r\n     const url = \"http://localhost:8088/system/webdev/Experimenting/Speak/doPost_ReadWriteTag\";\r\n     const payload = srtResult;\r\n     const resultEl = document.getElementById('result');\r\n   \r\n     try {\r\n       const response = await fetch(url, {\r\n         method: 'POST',\r\n         headers: {\r\n           'Content-Type' : 'text/plain'\r\n         },\r\n         body : payload\r\n       });\r\n   \r\n       const text = await response.text();\r\n            } \r\n     catch (err) {\r\n       console.log(text);\r\n      }\r\n   }\r\n   \r\n   \r\n   </script>\r\n\r\n</body>\r\n</html>\r\n"
}